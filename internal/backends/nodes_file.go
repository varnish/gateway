package backends

import (
	"fmt"
	"slices"
	"strings"
)

// Endpoint represents a single backend endpoint.
type Endpoint struct {
	IP   string
	Port int
}

// ServiceEndpoints maps service names to their endpoints.
type ServiceEndpoints map[string][]Endpoint

// Generate produces the INI-format backends.conf content that the nodes vmod expects.
// Output is deterministic: services and endpoints are sorted for consistent output.
func Generate(services ServiceEndpoints) string {
	var sb strings.Builder

	sb.WriteString("# Generated by varnish-gateway sidecar\n")
	sb.WriteString("# Do not edit - this file is auto-generated\n")

	// Sort service names for deterministic output
	serviceNames := make([]string, 0, len(services))
	for name := range services {
		serviceNames = append(serviceNames, name)
	}
	slices.Sort(serviceNames)

	for _, serviceName := range serviceNames {
		endpoints := services[serviceName]

		sb.WriteString("\n[")
		sb.WriteString(serviceName)
		sb.WriteString("]\n")

		// Sort endpoints for deterministic output
		sortedEndpoints := make([]Endpoint, len(endpoints))
		copy(sortedEndpoints, endpoints)
		slices.SortFunc(sortedEndpoints, func(a, b Endpoint) int {
			if a.IP != b.IP {
				return strings.Compare(a.IP, b.IP)
			}
			return a.Port - b.Port
		})

		for _, ep := range sortedEndpoints {
			backendName := sanitizeIdentifier(ep.IP)
			sb.WriteString(backendName)
			sb.WriteString(" = ")
			sb.WriteString(ep.IP)
			sb.WriteString(":")
			sb.WriteString(fmt.Sprintf("%d", ep.Port))
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// sanitizeIdentifier converts an IP address into a valid VCL identifier.
// Dots and colons are replaced with underscores, prefixed with "pod_".
func sanitizeIdentifier(ip string) string {
	s := strings.ReplaceAll(ip, ".", "_")
	s = strings.ReplaceAll(s, ":", "_")
	return "pod_" + s
}
