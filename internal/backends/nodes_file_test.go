package backends

import (
	"strings"
	"testing"
)

func TestGenerate_SingleServiceMultipleEndpoints(t *testing.T) {
	services := ServiceEndpoints{
		"svc_foo": {
			{IP: "10.0.0.1", Port: 8080},
			{IP: "10.0.0.2", Port: 8080},
		},
	}

	result := Generate(services)

	if !strings.Contains(result, "[svc_foo]") {
		t.Error("expected section header [svc_foo]")
	}
	if !strings.Contains(result, "pod_10_0_0_1 = 10.0.0.1:8080") {
		t.Error("expected endpoint pod_10_0_0_1")
	}
	if !strings.Contains(result, "pod_10_0_0_2 = 10.0.0.2:8080") {
		t.Error("expected endpoint pod_10_0_0_2")
	}
}

func TestGenerate_MultipleServices(t *testing.T) {
	services := ServiceEndpoints{
		"svc_bar": {
			{IP: "10.0.1.1", Port: 8080},
		},
		"svc_foo": {
			{IP: "10.0.0.1", Port: 8080},
		},
	}

	result := Generate(services)

	// Both sections should exist
	if !strings.Contains(result, "[svc_bar]") {
		t.Error("expected section header [svc_bar]")
	}
	if !strings.Contains(result, "[svc_foo]") {
		t.Error("expected section header [svc_foo]")
	}

	// svc_bar should come before svc_foo (alphabetical order)
	barIdx := strings.Index(result, "[svc_bar]")
	fooIdx := strings.Index(result, "[svc_foo]")
	if barIdx > fooIdx {
		t.Error("expected services to be sorted alphabetically")
	}
}

func TestGenerate_EmptyEndpoints(t *testing.T) {
	services := ServiceEndpoints{
		"svc_empty": {},
	}

	result := Generate(services)

	// Section header should still exist
	if !strings.Contains(result, "[svc_empty]") {
		t.Error("expected section header [svc_empty] even with no endpoints")
	}
}

func TestGenerate_EmptyMap(t *testing.T) {
	services := ServiceEndpoints{}

	result := Generate(services)

	// Should have header comments but no sections
	if !strings.Contains(result, "# Generated by varnish-gateway sidecar") {
		t.Error("expected header comment")
	}
	if strings.Contains(result, "[") {
		t.Error("expected no sections for empty map")
	}
}

func TestGenerate_DeterministicOutput(t *testing.T) {
	services := ServiceEndpoints{
		"svc_z": {
			{IP: "10.0.2.2", Port: 8080},
			{IP: "10.0.2.1", Port: 8080},
		},
		"svc_a": {
			{IP: "10.0.1.2", Port: 9090},
			{IP: "10.0.1.1", Port: 9090},
		},
	}

	// Generate multiple times and verify output is identical
	first := Generate(services)
	for i := 0; i < 10; i++ {
		result := Generate(services)
		if result != first {
			t.Errorf("output not deterministic on iteration %d", i)
		}
	}

	// Verify order: svc_a before svc_z, and endpoints sorted by IP
	lines := strings.Split(first, "\n")
	var svcAIdx, svcZIdx int
	for i, line := range lines {
		if line == "[svc_a]" {
			svcAIdx = i
		}
		if line == "[svc_z]" {
			svcZIdx = i
		}
	}
	if svcAIdx > svcZIdx {
		t.Error("expected svc_a before svc_z")
	}
}

func TestGenerate_IPv6Address(t *testing.T) {
	services := ServiceEndpoints{
		"svc_ipv6": {
			{IP: "2001:db8::1", Port: 8080},
		},
	}

	result := Generate(services)

	// Colons should be replaced with underscores
	if !strings.Contains(result, "pod_2001_db8__1 = 2001:db8::1:8080") {
		t.Errorf("expected IPv6 address handling, got:\n%s", result)
	}
}

func TestSanitizeIdentifier(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"10.0.0.1", "pod_10_0_0_1"},
		{"192.168.1.100", "pod_192_168_1_100"},
		{"2001:db8::1", "pod_2001_db8__1"},
		{"::1", "pod___1"},
	}

	for _, tc := range tests {
		result := sanitizeIdentifier(tc.input)
		if result != tc.expected {
			t.Errorf("sanitizeIdentifier(%q) = %q, expected %q", tc.input, result, tc.expected)
		}
	}
}

func TestGenerate_DifferentPorts(t *testing.T) {
	services := ServiceEndpoints{
		"svc_multi_port": {
			{IP: "10.0.0.1", Port: 8080},
			{IP: "10.0.0.1", Port: 9090},
		},
	}

	result := Generate(services)

	if !strings.Contains(result, "pod_10_0_0_1 = 10.0.0.1:8080") {
		t.Error("expected endpoint with port 8080")
	}
	if !strings.Contains(result, "pod_10_0_0_1 = 10.0.0.1:9090") {
		t.Error("expected endpoint with port 9090")
	}
}
