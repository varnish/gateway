//! Configuration loading and parsing for Ghost VMOD.
//!
//! Ghost routes incoming HTTP requests to upstream Kubernetes pods based on
//! the Host header and URL path. This module handles the ghost.json config
//! file which is generated by chaperone from Kubernetes routing rules and
//! EndpointSlice discoveries.

use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// A single upstream pod endpoint discovered from Kubernetes EndpointSlices.
#[derive(Debug, Clone, Deserialize)]
pub struct Backend {
    pub address: String,
    pub port: u16,
    #[serde(default = "default_weight")]
    pub weight: u32,
}

fn default_weight() -> u32 {
    100
}


/// Mirrors Gateway API's HTTPPathMatch types for URL routing decisions.
#[derive(Debug, Clone, Deserialize, PartialEq)]
#[serde(rename_all = "PascalCase")]
pub enum PathMatchType {
    Exact,
    PathPrefix,
    RegularExpression,
}

/// URL path condition that must match for a route to be selected.
#[derive(Debug, Clone, Deserialize)]
pub struct PathMatch {
    #[serde(rename = "type")]
    pub match_type: PathMatchType,
    pub value: String,
}

/// Match type for headers and query parameters.
#[derive(Debug, Clone, Deserialize, PartialEq)]
#[serde(rename_all = "PascalCase")]
pub enum MatchType {
    Exact,
    RegularExpression,
}

/// Header matching rule.
#[derive(Debug, Clone, Deserialize)]
pub struct HeaderMatch {
    pub name: String,
    pub value: String,
    #[serde(rename = "type")]
    pub match_type: MatchType,
}

/// Query parameter matching rule.
#[derive(Debug, Clone, Deserialize)]
pub struct QueryParamMatch {
    pub name: String,
    pub value: String,
    #[serde(rename = "type")]
    pub match_type: MatchType,
}

/// Maps a URL path pattern to a set of backend pods.
/// Multiple routes per vhost enable path-based traffic splitting.
#[derive(Debug, Clone, Deserialize)]
pub struct Route {
    pub path_match: Option<PathMatch>,
    #[serde(default)]
    pub method: Option<String>,
    #[serde(default)]
    pub headers: Vec<HeaderMatch>,
    #[serde(default)]
    pub query_params: Vec<QueryParamMatch>,
    pub backends: Vec<Backend>,
    pub priority: i32,
}

/// All routing rules for a single hostname (e.g., "api.example.com").
/// Derived from HTTPRoute resources targeting this hostname.
#[derive(Debug, Clone, Deserialize)]
pub struct VHost {
    pub routes: Vec<Route>,
    #[serde(default)]
    pub default_backends: Vec<Backend>,
}

/// Root configuration loaded from ghost.json.
/// Generated by chaperone, consumed by the ghost VMOD at runtime.
#[derive(Debug, Clone, Deserialize)]
pub struct Config {
    pub version: u32,
    #[serde(default)]
    pub vhosts: HashMap<String, VHost>,
}

/// Load and validate ghost.json from disk.
/// Returns an empty config if the file doesn't exist yet, allowing Varnish
/// to start before chaperone has generated the initial configuration.
pub fn load(path: &Path) -> Result<Config, String> {
    // If file doesn't exist, return empty config
    if !path.exists() {
        return Ok(Config::empty());
    }

    let content = fs::read_to_string(path)
        .map_err(|e| format!("failed to read config file {}: {}", path.display(), e))?;

    let config: Config = serde_json::from_str(&content)
        .map_err(|e| format!("failed to parse config file {}: {}", path.display(), e))?;

    validate(&config)?;

    Ok(config)
}

impl Config {
    /// Bootstrap config for startup when ghost.json hasn't been written yet.
    /// All requests will 404 until chaperone discovers endpoints and reloads.
    pub fn empty() -> Self {
        Config {
            version: 2,
            vhosts: HashMap::new(),
        }
    }
}

/// Catch config errors early rather than failing at request time.
fn validate(config: &Config) -> Result<(), String> {
    if config.version != 2 {
        return Err(format!(
            "unsupported config version: {} (expected 2)",
            config.version
        ));
    }

    for (hostname, vhost) in &config.vhosts {
        validate_hostname(hostname)?;

        for (i, route) in vhost.routes.iter().enumerate() {
            let route_ctx = format!("{} route {}", hostname, i);
            validate_backends(&route_ctx, &route.backends)?;

            if let Some(ref path_match) = route.path_match {
                validate_path_match(path_match, &route_ctx)?;
            }

            if let Some(ref method) = route.method {
                validate_method(method, &route_ctx)?;
            }

            for (j, header) in route.headers.iter().enumerate() {
                let header_ctx = format!("{} header {}", route_ctx, j);
                validate_header_match(header, &header_ctx)?;
            }

            for (j, qp) in route.query_params.iter().enumerate() {
                let qp_ctx = format!("{} query_param {}", route_ctx, j);
                validate_query_param_match(qp, &qp_ctx)?;
            }
        }

        if !vhost.default_backends.is_empty() {
            validate_backends(&format!("{} default_backends", hostname), &vhost.default_backends)?;
        }
    }

    Ok(())
}

/// Ensure vhost keys conform to Gateway API hostname rules.
/// Wildcards must be leading (*.example.com) to match the single-label
/// wildcard semantics defined in the Gateway API spec.
fn validate_hostname(hostname: &str) -> Result<(), String> {
    if hostname.is_empty() {
        return Err("hostname cannot be empty".to_string());
    }

    // Check for valid wildcard pattern
    if hostname.contains('*') {
        // Only allow leading wildcard: *.example.com
        if !hostname.starts_with("*.") {
            return Err(format!(
                "invalid wildcard hostname '{}': wildcard must be at start (*.example.com)",
                hostname
            ));
        }
        // No other wildcards allowed
        if hostname[2..].contains('*') {
            return Err(format!(
                "invalid wildcard hostname '{}': only single leading wildcard allowed",
                hostname
            ));
        }
    }

    Ok(())
}

/// Guard against misconfigured endpoints that would cause request failures.
/// Empty addresses or zero ports indicate EndpointSlice corruption or
/// chaperone bugs that should be surfaced at config load, not at request time.
fn validate_backends(context: &str, backends: &[Backend]) -> Result<(), String> {
    for (i, backend) in backends.iter().enumerate() {
        if backend.address.is_empty() {
            return Err(format!(
                "backend {} in '{}': address cannot be empty",
                i, context
            ));
        }
        if backend.port == 0 {
            return Err(format!("backend {} in '{}': port cannot be 0", i, context));
        }
        if backend.weight == 0 {
            return Err(format!(
                "backend {} in '{}': weight cannot be 0",
                i, context
            ));
        }
    }
    Ok(())
}


/// Enforce Gateway API path constraints and catch regex errors early.
/// Invalid regexes would panic at match time; malformed paths indicate
/// operator bugs that should fail loudly during config reload.
fn validate_path_match(path_match: &PathMatch, context: &str) -> Result<(), String> {
    match path_match.match_type {
        PathMatchType::Exact | PathMatchType::PathPrefix => {
            // Paths must start with /
            if !path_match.value.starts_with('/') {
                return Err(format!(
                    "{}: path '{}' must start with /",
                    context, path_match.value
                ));
            }
            // No consecutive slashes
            if path_match.value.contains("//") {
                return Err(format!(
                    "{}: path '{}' cannot contain consecutive slashes",
                    context, path_match.value
                ));
            }
        }
        PathMatchType::RegularExpression => {
            // Regex patterns have a max length
            if path_match.value.len() > 1024 {
                return Err(format!(
                    "{}: regex pattern too long ({} chars, max 1024)",
                    context,
                    path_match.value.len()
                ));
            }
            // IMPORTANT: Don't compile regex here!
            //
            // Regex compilation is deferred to build_routing_state() because:
            // 1. This validation runs from Varnish worker threads during reload
            // 2. The regex crate uses thread-local storage (TLS) for its internal caches
            // 3. Varnish's C threads don't properly initialize Rust's TLS mechanism
            // 4. In debug mode, this causes SIGABRT when Regex::new() accesses uninitialized TLS
            // 5. Release mode works because optimizations reduce TLS dependencies
            //
            // The regex will be compiled during routing state build where:
            // - Compilation errors can be caught and reported via Result
            // - The pattern is stored in PathMatchCompiled for efficient matching
            //
            // See DEBUG_MODE_LIMITATIONS.md for detailed explanation.
        }
    }
    Ok(())
}

/// Validate HTTP method
fn validate_method(method: &str, context: &str) -> Result<(), String> {
    const VALID_METHODS: &[&str] = &[
        "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH",
    ];
    if !VALID_METHODS.contains(&method) {
        return Err(format!("{}: invalid method '{}'", context, method));
    }
    Ok(())
}

/// Validate header match configuration
fn validate_header_match(header: &HeaderMatch, context: &str) -> Result<(), String> {
    if header.name.is_empty() {
        return Err(format!("{}: header name cannot be empty", context));
    }
    if header.value.is_empty() {
        return Err(format!("{}: header value cannot be empty", context));
    }
    if header.value.len() > 4096 {
        return Err(format!(
            "{}: header value too long ({} chars, max 4096)",
            context,
            header.value.len()
        ));
    }
    if header.match_type == MatchType::RegularExpression {
        // Regex compilation deferred - see detailed comment in validate_path_match()
    }
    Ok(())
}

/// Validate query parameter match configuration
fn validate_query_param_match(qp: &QueryParamMatch, context: &str) -> Result<(), String> {
    if qp.name.is_empty() {
        return Err(format!("{}: query param name cannot be empty", context));
    }
    if qp.value.is_empty() {
        return Err(format!("{}: query param value cannot be empty", context));
    }
    if qp.value.len() > 1024 {
        return Err(format!(
            "{}: query param value too long ({} chars, max 1024)",
            context,
            qp.value.len()
        ));
    }
    if qp.match_type == MatchType::RegularExpression {
        // Regex compilation deferred - see detailed comment in validate_path_match()
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    fn write_config(content: &str) -> NamedTempFile {
        let mut file = NamedTempFile::new().unwrap();
        write!(file, "{}", content).unwrap();
        file
    }

    #[test]
    fn test_load_minimal_config() {
        let file = write_config(r#"{"version": 2}"#);
        let config = load(file.path()).unwrap();
        assert_eq!(config.version, 2);
        assert!(config.vhosts.is_empty());
    }

    #[test]
    fn test_load_nonexistent_file() {
        // Loading a non-existent file should return an empty config
        let path = Path::new("/nonexistent/ghost.json");
        let config = load(path).unwrap();
        assert_eq!(config.version, 2);
        assert!(config.vhosts.is_empty());
    }

    #[test]
    fn test_load_full_config() {
        let file = write_config(
            r#"{
            "version": 2,
            "vhosts": {
                "api.example.com": {
                    "routes": [
                        {
                            "path_match": {"type": "PathPrefix", "value": "/api"},
                            "backends": [
                                {"address": "10.0.0.1", "port": 8080, "weight": 100},
                                {"address": "10.0.0.2", "port": 8080, "weight": 50}
                            ],
                            "priority": 100
                        }
                    ]
                },
                "*.staging.example.com": {
                    "routes": [
                        {
                            "backends": [
                                {"address": "10.0.1.1", "port": 80}
                            ],
                            "priority": 100
                        }
                    ]
                }
            }
        }"#,
        );

        let config = load(file.path()).unwrap();
        assert_eq!(config.version, 2);
        assert_eq!(config.vhosts.len(), 2);
        assert!(config.vhosts.contains_key("api.example.com"));
        assert!(config.vhosts.contains_key("*.staging.example.com"));

        let api = &config.vhosts["api.example.com"];
        assert_eq!(api.routes.len(), 1);
        assert_eq!(api.routes[0].backends.len(), 2);
        assert_eq!(api.routes[0].backends[0].weight, 100);
        assert_eq!(api.routes[0].backends[1].weight, 50);

        let staging = &config.vhosts["*.staging.example.com"];
        assert_eq!(staging.routes.len(), 1);
        assert_eq!(staging.routes[0].backends.len(), 1);
        assert_eq!(staging.routes[0].backends[0].weight, 100); // default weight
    }

    #[test]
    fn test_invalid_version() {
        let file = write_config(r#"{"version": 0}"#);
        let result = load(file.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("unsupported config version"));
    }

    #[test]
    fn test_invalid_wildcard_middle() {
        let file =
            write_config(r#"{"version": 2, "vhosts": {"foo.*.example.com": {"routes": []}}}"#);
        let result = load(file.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("wildcard must be at start"));
    }

    #[test]
    fn test_invalid_wildcard_double() {
        let file =
            write_config(r#"{"version": 2, "vhosts": {"*.*.example.com": {"routes": []}}}"#);
        let result = load(file.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("only single leading wildcard"));
    }

    #[test]
    fn test_invalid_backend_empty_address() {
        let file = write_config(
            r#"{"version": 2, "vhosts": {"foo.com": {"routes": [{"backends": [{"address": "", "port": 80}], "priority": 100}]}}}"#,
        );
        let result = load(file.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("address cannot be empty"));
    }

    #[test]
    fn test_invalid_backend_zero_port() {
        let file = write_config(
            r#"{"version": 2, "vhosts": {"foo.com": {"routes": [{"backends": [{"address": "1.2.3.4", "port": 0}], "priority": 100}]}}}"#,
        );
        let result = load(file.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("port cannot be 0"));
    }

    #[test]
    fn test_invalid_backend_zero_weight() {
        let file = write_config(
            r#"{"version": 2, "vhosts": {"foo.com": {"routes": [{"backends": [{"address": "1.2.3.4", "port": 80, "weight": 0}], "priority": 100}]}}}"#,
        );
        let result = load(file.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("weight cannot be 0"));
    }
}
