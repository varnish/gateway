varnishtest "ghost IPv6 backend address parsing"

# This test verifies that ghost can:
# 1. Parse IPv6 addresses from ghost.json config (compressed and full notation)
# 2. Create NativeBackend instances with IPv6 SocketAddr
# 3. Route requests to IPv6 backends
# 4. Handle multiple backends on the same IPv6 address with different ports
#    (backend keys like "::1:port1", "::1:port2" must be unique)
#
# Coverage:
# - IPv6 compressed notation: "::1"
# - IPv6 full notation: "0000:0000:0000:0000:0000:0000:0000:0001"
# - Backend key uniqueness for IPv6 addresses with multiple ports

# Backend server 1 - tests IPv6 compressed notation (::1)
server s1 -listen "::1 0" {
    rxreq
    expect req.http.host == "api.example.com"
    expect req.http.x-forwarded-host == "api.example.com"
    txresp -body "ipv6-compressed"
} -start

# Backend server 2 - tests IPv6 full notation
server s2 -listen "::1 0" {
    rxreq
    expect req.http.host == "full.example.com"
    txresp -body "ipv6-full"
} -start

# Backend server 3 - tests multiple backends on same IPv6 address, different ports
server s3 -listen "::1 0" {
    rxreq
    expect req.http.host == "multi.example.com"
    txresp -body "ipv6-multi"
} -start

# Write config file with various IPv6 address formats
# Tests: compressed (::1), full notation, and backend key uniqueness
shell {
    cat > ${tmpdir}/ghost.json <<EOF
{
    "version": 2,
    "vhosts": {
        "api.example.com": {
            "routes": [
                {
                    "backends": [
                        {"address": "::1", "port": ${s1_port}, "weight": 100}
                    ],
                    "priority": 100
                }
            ]
        },
        "full.example.com": {
            "routes": [
                {
                    "backends": [
                        {"address": "0000:0000:0000:0000:0000:0000:0000:0001", "port": ${s2_port}, "weight": 100}
                    ],
                    "priority": 100
                }
            ]
        },
        "multi.example.com": {
            "routes": [
                {
                    "backends": [
                        {"address": "::1", "port": ${s3_port}, "weight": 100}
                    ],
                    "priority": 100
                }
            ]
        }
    }
}
EOF
}

varnish v1 -arg "-p thread_pool_stack=160k" -vcl {
    import ghost from "${vmod}";

    backend dummy none;

    sub vcl_init {
        ghost.init("${tmpdir}/ghost.json");
        new router = ghost.ghost_backend();
    }

    sub vcl_recv {
        if (req.url == "/.varnish-ghost/reload") {
            if (router.reload()) {
                return (synth(200, "OK"));
            } else {
                return (synth(500, "Reload failed"));
            }
        }
    }

    sub vcl_backend_fetch {
        set bereq.backend = router.backend();

        # Preserve original Host header for backends
        if (bereq.http.host) {
            set bereq.http.x-forwarded-host = bereq.http.host;
        }
    }
} -start

# Initial reload to load configuration
client c_reload {
    txreq -url "/.varnish-ghost/reload"
    rxresp
    expect resp.status == 200
} -run

# Test 1: Route to IPv6 backend with compressed notation (::1)
client c1 {
    txreq -hdr "Host: api.example.com"
    rxresp
    expect resp.status == 200
    expect resp.body == "ipv6-compressed"
} -run

# Test 2: Route to IPv6 backend with full address notation
# Tests that "0000:0000:0000:0000:0000:0000:0000:0001" parses correctly
client c2 {
    txreq -hdr "Host: full.example.com"
    rxresp
    expect resp.status == 200
    expect resp.body == "ipv6-full"
} -run

# Test 3: Route to third IPv6 backend on same address, different port
# Tests that backend keys "::1:port1", "::1:port2", "::1:port3" are unique
client c3 {
    txreq -hdr "Host: multi.example.com"
    rxresp
    expect resp.status == 200
    expect resp.body == "ipv6-multi"
} -run
